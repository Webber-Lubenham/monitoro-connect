
import { dbClient, logOperation } from '../../base/baseService';
import { findUserByEmail } from '@/integrations/supabase/authUtils';
import { verifyStudentExists, checkExistingGuardianByEmail, checkExistingGuardianByCpf } from '../validation/guardianValidation';

export interface GuardianData {
  nome: string;
  email: string;
  telefone?: string; // Optional but not null
  is_primary?: boolean;
  cpf?: string;
}

export const addGuardian = async (
  studentId: string, 
  guardianData: GuardianData
): Promise<{ success: boolean; tempPassword?: string }> => {
  try {
    logOperation(`Adicionando responsável ${guardianData.nome} (${guardianData.email}) para o aluno ${studentId}`);
    
    const normalizedEmail = guardianData.email.toLowerCase().trim();
    
    // Check if the student exists
    const { exists: studentExists, studentData } = await verifyStudentExists(studentId);
    if (!studentExists) {
      logOperation(`Estudante não encontrado com ID: ${studentId}`);
      return { success: false };
    }
    
    // Check existing guardian
    const guardianExists = await checkExistingGuardianByEmail(studentId, normalizedEmail);
    if (guardianExists) {
      logOperation(`Responsável já existe para este aluno: ${normalizedEmail}`);
      return { success: false };
    }
    
    // Check CPF if provided
    if (guardianData.cpf) {
      const guardianExistsByCpf = await checkExistingGuardianByCpf(studentId, guardianData.cpf);
      if (guardianExistsByCpf) {
        logOperation(`Responsável já existe para este aluno com CPF: ${guardianData.cpf}`);
        return { success: false };
      }
    }
    
    // Add guardian to database - temp_password will be auto-generated by trigger
    const { data: guardian, error } = await dbClient
      .from('guardians')
      .insert({
        student_id: studentId,
        nome: guardianData.nome,
        email: normalizedEmail,
        telefone: guardianData.telefone ?? '', // Use nullish coalescing
        is_primary: guardianData.is_primary || false,
        cpf: guardianData.cpf ?? '' // Use nullish coalescing here too for consistency
      })
      .select('temp_password')
      .single();
    
    if (error) {
      logOperation(`Erro ao adicionar responsável: ${error.message}`);
      throw error;
    }

    // Convert null to undefined for the temp_password
    const tempPassword = guardian?.temp_password || undefined;

    // Send invitation email with temp password
    try {
      const response = await dbClient.functions.invoke('send-guardian-invitation', {
        body: {
          guardianEmail: normalizedEmail,
          guardianName: guardianData.nome,
          studentName: studentData?.name || 'aluno',
          tempPassword: guardian.temp_password,
          guardianCpf: guardianData.cpf // Enviar CPF para a função de convite
        }
      });

      if (response.error) {
        console.error('Error sending invitation:', response.error);
      }
    } catch (emailError) {
      console.error('Failed to send invitation email:', emailError);
      // Continue anyway - guardian was created
    }
    
    logOperation(`Responsável adicionado com sucesso`);
    return { 
      success: true,
      tempPassword 
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logOperation(`Exceção em addGuardian: ${errorMessage}`);
    console.error('Error in addGuardian:', error);
    return { success: false };
  }
};
